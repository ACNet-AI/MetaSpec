---
description: Define toolkit specification (SDD - Spec-Driven Development)
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Outline

The text the user typed after `/metaspec.sdd.specify` is the **toolkit specification description**. 

**PURPOSE: Toolkit Specification (SDD)** üéØ

This command is for defining **toolkit implementation specifications**:
- Focus: HOW to implement the toolkit
- Output: `specs/toolkit/001-{name}/spec.md`
- Must depend on protocol specs
- Implementation-focused

**NOT for protocol definition** - Use `/metaspec.sds.specify` for that.

Follow this execution flow:

### 1. Determine Toolkit and Load Existing Specification

**Step 1a: Verify Protocol Dependency (REQUIRED)**

```bash
# Check if protocol specs exist
ls specs/protocol/ | grep -E '^[0-9]{3}-'
```

**CRITICAL REQUIREMENT**: Toolkit specs MUST depend on at least one protocol spec.

If no protocol specs exist, **STOP** and show this error:

```
‚ùå ERROR: Cannot create toolkit without protocol specification

MetaSpec is a Spec-Driven framework. Every toolkit MUST depend on a protocol.

The protocol defines WHAT (domain specification).
The toolkit defines HOW (implementation).

Please run this command first:
  /metaspec.sds.specify "Define {domain} protocol"

Then return to create toolkit with:
  /metaspec.sdd.specify "Create {toolkit} for {domain}"

Why this matters:
- Protocol is the specification (core asset)
- Toolkit is the implementation (supporting tool)
- Without protocol, this becomes a generic code generator
- MetaSpec's value is in spec-driven development
```

**Do not proceed** if no protocol specs exist.

**Step 1b: Generate Toolkit Name**

Based on user input, generate:
- Short name: `{domain}-{component}`
- Example: "mcp-parser", "graphql-validator", "oauth-client"
- Check existing `specs/toolkit/` directory structure

**Step 1c: Find Next Available Number**

```bash
# List existing toolkit specs
ls specs/toolkit/ | grep -E '^[0-9]{3}-' | sort -n
# Find next number (e.g., if 001, 002 exist, use 003)
```

**Step 1d: Load Existing or Create New**

- Check for `specs/toolkit/{number}-{name}/spec.md`
- If exists, load for updating
- If new, create new directory structure

### 2. Gather Toolkit Specification Content

**Focus**: Define how to implement tools to support the protocol.

**Critical Questions**:

1. **Dependencies**: Which protocol specs does this toolkit support?
   - **REQUIRED**: Must reference at least one `protocol/XXX-` spec
   - Example: "Depends on: protocol/001-mcp-core-protocol"
   
2. **Toolkit Purpose**: What does this toolkit do?
   - Example: "Parse and validate MCP server definitions"
   
3. **Implementation Language** (NEW - CRITICAL üéØ):
   - **Primary language**: Python / TypeScript / Go / Rust / Other?
   - **Rationale**: Why this language?
     - Target user community (Python devs, TS/JS devs, etc.)
     - Ecosystem fit (existing tools, libraries)
     - Performance requirements
     - Deployment constraints
   - **Secondary languages**: Any additional language support needed?
   
4. **Required Components** (NEW - CRITICAL üéØ):
   Determine which components are needed for this toolkit:
   
   - [ ] **Parser** - Parse specifications from files
     - Needed if: Users write specs in files (YAML/JSON/TOML)
     - Not needed if: Specs are generated programmatically
   
   - [ ] **Validator** - Validate against protocol rules
     - Needed if: Need to enforce protocol compliance
     - Always recommended for spec-driven toolkits
   
   - [ ] **CLI** - Command-line interface
     - Needed if: Users interact via terminal
     - Provides: init, validate, generate commands
   
   - [ ] **Generator** - Generate code/docs from specs
     - Needed if: Want to automate code generation
     - Examples: Generate TypeScript types, Python classes
   
   - [ ] **SDK/Library** - Programmatic API
     - Needed if: Other tools need to integrate
     - Provides: Python/TS/Go module for importing
   
   **Which are MVP (must have) vs. future enhancements (nice to have)?**
   
5. **Architecture Direction** (NEW üéØ):
   - **Structure**: Monolithic / Modular / Plugin-based?
   - **Dependencies**: What frameworks/libraries?
     - Examples: Pydantic (Python), Zod (TypeScript), encoding/json (Go)
   - **Extensibility**: Plugin system / Hooks / Base classes?
   
6. **Parser Component** (if needed): How will specifications be parsed?
   - Input formats (YAML, JSON, TOML, other)?
   - Output format (Objects, AST, IR)?
   
7. **Validator Component** (if needed): What validation will it perform?
   - Must validate against protocol rules
   - What error messages/codes?
   
8. **CLI Commands** (if needed): What commands will users run?
   - Example: `{toolkit-name} init`, `validate`, `generate`
   - What are the inputs/outputs for each command?

9. **Generator Component** (if needed): What will it generate?
   - Output formats: Code (Python/TS/Go), Docs (MD), Config (JSON/YAML)?
   - Templates: Built-in / User-provided / Both?

10. **SDK/Library** (if needed): Will there be programmatic APIs?
    - Public API surface: What functions/classes?
    - Integration: How will other tools use this?

**Important Notes**:
- This is SDD (Spec-Driven Development) - focus on implementation
- Must explicitly depend on protocol specs
- For protocol definition, use `/metaspec.sds.specify` instead

**If user input is vague**, make informed guesses based on domain standards and document assumptions.

### 3. Generate Toolkit Specification Content

Generate **Toolkit Implementation Specification** with these sections:

#### **Dependencies Section** (REQUIRED - CRITICAL)

**First and foremost**, declare dependencies on protocol specifications:

```markdown
## Dependencies

**Protocol Specifications**:
- **protocol/001-{domain}-protocol** - {Brief description of what protocol defines}

### Dependency Rationale

{Explain how this toolkit depends on the protocol:}
- Which protocol entities are parsed/validated?
- Which protocol rules are enforced?
- How does the toolkit implement protocol operations?

**Important**: 
- This toolkit MUST reference at least one protocol specification
- Changes to protocol specs may require updates to this toolkit
- Without protocol dependency, this violates the Spec-Driven principle
```

**CRITICAL**: This Dependencies section is mandatory. Toolkit without protocol is not a valid speckit.

#### **Toolkit Overview**
```markdown
## Overview

**Name**: {Toolkit Name}
**Version**: {version}
**Status**: Draft | In Development | Stable
**Created**: {date}

**Purpose**: {What this toolkit does}

**Target Protocol**: Implements support for protocol/001-{domain}-protocol

**Primary Use Cases**:
1. {Use case 1}
2. {Use case 2}
3. {Use case 3}

**Example**:
```bash
# How users will use this toolkit
{toolkit-name} init spec.yaml
{toolkit-name} validate spec.yaml
{toolkit-name} generate --output ./generated
```
\```

#### **Implementation Details** (NEW üéØ)
```markdown
## Implementation

### Language & Ecosystem

**Primary Language**: {Python / TypeScript / Go / Rust / Other}

**Rationale**: 
{Why this language was chosen:}
- Target user community: {who will use this}
- Ecosystem fit: {existing tools and libraries}
- Performance considerations: {if relevant}
- Deployment needs: {pip / npm / binary / etc.}

**Key Dependencies**:
- {Framework/library 1}: {Purpose}
- {Framework/library 2}: {Purpose}
- {Framework/library 3}: {Purpose}

### Architecture

**Structure**: {Monolithic / Modular / Plugin-based}

**Core Components**:
- [ ] Parser - {Brief description}
- [ ] Validator - {Brief description}
- [ ] CLI - {Brief description}
- [ ] Generator - {Brief description if included}
- [ ] SDK - {Brief description if included}

**Extensibility**:
{How will users extend this toolkit:}
- Plugin system / Custom validators / Hooks / etc.

**File Structure** (Preliminary):
```
src/
  {package_name}/
    __init__.py         # Package initialization
    models.py           # Data models (if needed)
    parser.py           # Parser component (if needed)
    validator.py        # Validator component (if needed)
    cli.py              # CLI component (if needed)
    generator.py        # Generator component (if needed)
    api.py              # SDK interface (if needed)
```

Note: Actual structure will be refined in `/metaspec.sdd.plan`
\```

#### **Component Specifications**

Define each toolkit component:

##### **Component 1: Parser**

```markdown
### Parser Component

**Purpose**: Parse user specifications into validated objects

**Input Formats**:
- YAML (primary)
- JSON (alternative)
- Python dict (programmatic)

**Output Format**:
- Validated Python object
- AST representation (if needed)

**Parsing Steps**:
1. Load file (YAML/JSON)
2. Validate schema structure
3. Transform to internal representation
4. Return parsed object or errors

**Error Handling**:
- `ParseError`: Invalid YAML/JSON syntax
- `SchemaError`: Missing required fields
- `TypeE Error`: Incorrect field types

**API**:
```python
from {toolkit_name}.parser import parse_spec

# Parse from file
spec = parse_spec("spec.yaml")

# Parse from string
spec = parse_spec(yaml_string, format="yaml")

# Parse from dict
spec = parse_spec(spec_dict, format="dict")
```
\```

##### **Component 2: Validator**

```markdown
### Validator Component

**Purpose**: Validate specifications against protocol rules (from protocol/001-xxx)

**Validation Rules** (Reference protocol spec):
1. {Rule from protocol/001-xxx}
2. {Rule from protocol/001-xxx}
3. {Rule from protocol/001-xxx}

**Validation Levels**:
- **Error**: Violations that prevent usage
- **Warning**: Issues that should be fixed
- **Info**: Suggestions for improvement

**Validation Output**:
```python
ValidationResult(
    valid: bool,
    errors: List[ValidationError],
    warnings: List[ValidationWarning],
    info: List[ValidationInfo]
)
```

**Error Messages**:
- Clear, actionable error messages
- Point to exact location in spec
- Suggest fixes when possible

**API**:
```python
from {toolkit_name}.validator import validate_spec

# Validate parsed spec
result = validate_spec(spec)

if not result.valid:
    for error in result.errors:
        print(f"{error.location}: {error.message}")
```
\```

##### **Component 3: CLI**

```markdown
### CLI Component

**Purpose**: Provide command-line interface for toolkit

**Commands**:

#### `init` - Create new specification
```bash
{toolkit-name} init [filename]

Options:
  --template [name]  Use specific template
  --interactive      Interactive mode
```

#### `validate` - Validate specification
```bash
{toolkit-name} validate [filename]

Options:
  --strict           Treat warnings as errors
  --format [json]    Output format
```

#### `generate` - Generate artifacts
```bash
{toolkit-name} generate [filename]

Options:
  --output [dir]     Output directory
  --template [name]  Template to use
```

**CLI Framework**: typer or click
**Output**: Rich formatting with colors and progress
\```

##### **Component 4: Slash Commands - Spec-Driven Execution (CRITICAL for AI-Oriented Tools)**

**CRITICAL UNDERSTANDING**: Slash Commands are **NOT** CLI usage manuals. They are **spec-driven execution guides** that embed protocol knowledge and guide AI to produce spec-compliant outputs.

```markdown
### Slash Commands

**What they are**: Spec-driven execution guides with embedded protocol knowledge
**Where they go**: `templates/commands/` directory  
**How AI uses them**: Via `/` prefix in AI chat (Cursor, Windsurf, etc.)
**Core purpose**: Guide AI to **produce outputs that comply with protocol specifications**

**Key Distinction**:
- ‚ùå **NOT**: "How to call CLI commands" (wrapper documentation)
- ‚úÖ **YES**: "How to execute according to protocol specs" (spec-driven guidance)

**When to Include**:
- ‚úÖ Primary users are AI agents
- ‚úÖ Tool enforces a specific protocol/specification
- ‚úÖ Outputs must comply with validation rules
- ‚úÖ Multi-step workflows require protocol knowledge

---

#### STEP 1: Analyze Protocol Specification (REQUIRED)

**Before defining Slash Commands**, analyze the SDS protocol specification in `specs/protocol/`.

**Questions to Ask**:

1. **Protocol Complexity**
   - [ ] Does the protocol define complex rules and constraints?
   - [ ] Will AI need to reference these rules repeatedly?
   - **If YES** ‚Üí Need commands to access protocol knowledge

2. **Entities & Structures**
   - [ ] Does the protocol define multiple entity types?
   - [ ] Do entities have specific structures (schemas, fields, validation)?
   - **If YES** ‚Üí Need commands to work with entities

3. **Validation Rules**
   - [ ] Does the protocol specify validation constraints?
   - [ ] Must outputs be validated against schemas?
   - **If YES** ‚Üí Need validation commands

4. **Workflows & Phases**
   - [ ] Does the protocol define a multi-phase workflow?
   - [ ] Are there specific actions in each phase?
   - **If YES** ‚Üí Analyze workflow type:
     - **Type A (State Machine)**: Abstract states (draft ‚Üí review ‚Üí approved)
       ‚Üí Use navigation commands: `get-workflow`, `next-phase`
     - **Type B (Action Sequence)**: Concrete actions (define ‚Üí clarify ‚Üí validate)
       ‚Üí Each action becomes a command

5. **Examples & Templates**
   - [ ] Does the protocol include examples or templates?
   - [ ] Will AI need to reference these?
   - **If YES** ‚Üí Need commands to retrieve examples

---

#### STEP 2: Derive Commands from Protocol

**Mapping Rules**: Protocol content ‚Üí Commands

| Protocol Content | Indicator | Derived Command | Purpose |
|-----------------|-----------|-----------------|---------|
| **Complex rules** | 20+ pages, many constraints | `get-spec [section]` | Access protocol knowledge |
| **Multiple entities** | 3+ entity definitions | `get-template <entity>` | Retrieve entity structures |
| **Validation rules** | JSON schemas, constraints | `validate <file>` | Check compliance |
| **Workflow (Type A)** | States & transitions | `get-workflow`, `next-phase` | Navigate workflow |
| **Workflow (Type B)** | Action sequences | One command per action | Execute each step |
| **Examples** | Example library | `get-example <type>` | Reference examples |
| **Operations** | Interface definitions | `get-spec operations` | Access interface specs |

**Example Analysis - MCP Protocol**:

```markdown
Protocol Analysis (specs/protocol/001-mcp/spec.md):

‚úÖ Complexity: High (5 phases, 20+ validation rules)
‚úÖ Entities: 5 artifact types (requirements, design, code, tests, deployment)
‚úÖ Validation: Each entity has JSON schema
‚úÖ Workflow: Type B - Action sequence per phase
‚úÖ Examples: Template for each artifact type

Derived Commands:
  P0 (CRITICAL):
    - get-spec        (Access protocol rules)
    - get-template    (Retrieve artifact templates)
    - validate        (Check schema compliance)
    
  P1 (Important):
    - get-workflow    (Show phase structure)
    - get-example     (Reference examples)
    - init            (Initialize project)
    
  P2 (Optional - Skip):
    - info            (Low value)
```

---

#### STEP 3: Create Spec-Driven Slash Commands

**CRITICAL**: Slash Commands embed protocol knowledge and guide spec-driven execution.

**Template Structure**:

```markdown
# /{toolkit-name}.{command}

## Purpose
[Spec-driven goal - what protocol-compliant output to produce]

## Protocol Specification (EMBEDDED)
**From**: specs/protocol/{XXX}/spec.md

### Entity Structure
[Copy relevant entity definition from protocol]
- field1: type (required) - description
- field2: type (optional) - description
- Constraints: [Protocol constraints]

### Validation Rules
[Copy validation rules from protocol]
- VR001: {Rule description}
- VR002: {Rule description}

### Examples
[Include protocol examples]

## AI Execution Steps
[How AI should execute to produce spec-compliant output]

1. **Understand User Intent**
   - Extract key information from user input
   - Map to protocol entity structure

2. **Apply Protocol Rules**
   - Check {constraint 1}
   - Ensure {constraint 2}
   - Validate {rule 3}

3. **Structure Output**
   - Follow entity schema
   - Include required fields
   - Apply validation rules

4. **Validate Compliance**
   - Self-check against protocol rules
   - Verify all constraints met

## Output Template
[Protocol-compliant output structure]

\```json
{
  "field1": "...",  // From protocol entity definition
  "field2": "..."   // Validated against VR001
}
\```

## Validation Checklist
[From protocol validation_rules]
- [ ] VR001: {Rule}
- [ ] VR002: {Rule}
- [ ] Output matches schema

## Related Commands
- /{toolkit}.get-spec - Reference full protocol
- /{toolkit}.validate - Validate output
\```

---

#### STEP 4: Workflow-Specific Commands

**If protocol defines Type B Workflow (Action Sequence)**:

```markdown
Protocol Workflow Example:
  phases:
    - Requirements:
        actions:
          - define_requirements
          - clarify_requirements
          - validate_requirements
    - Design:
        actions:
          - create_design
          - review_design

Slash Commands Needed:
  /{toolkit}.define-requirements.md
  /{toolkit}.clarify-requirements.md
  /{toolkit}.validate-requirements.md
  /{toolkit}.create-design.md
  /{toolkit}.review-design.md

Each contains:
  - Protocol knowledge for that phase
  - Spec-driven execution steps
  - Validation rules for outputs
```

**Judgment Rule**: 
- Workflow step is a **verb/action** ‚Üí Create command
- Workflow step is a **noun/state** ‚Üí Use navigation commands

---

#### Slash Command Checklist

Based on protocol analysis, create:

**P0 - Must Create** (If protocol has these):
- [ ] `/{toolkit}.get-spec.md` - If complex protocol (20+ rules)
- [ ] `/{toolkit}.get-template.md` - If multiple entities (3+)
- [ ] `/{toolkit}.validate.md` - If validation rules exist
- [ ] `/{toolkit}.{action}.md` - For each workflow action (Type B)

**P1 - Should Create** (If useful):
- [ ] `/{toolkit}.get-workflow.md` - If multi-phase workflow
- [ ] `/{toolkit}.get-example.md` - If examples exist
- [ ] `/{toolkit}.init.md` - For project initialization

**P2 - Skip** (Low value):
- [ ] info, version, help commands

---

#### Design Principles: Spec-Driven Execution

1. **Embed Protocol Knowledge**
   - ‚úÖ Include entity definitions from protocol
   - ‚úÖ Copy validation rules into commands
   - ‚úÖ Provide protocol examples
   - ‚ùå Don't just say "call this CLI"

2. **Guide Spec-Compliant Production**
   - ‚úÖ Show how to structure outputs per protocol
   - ‚úÖ Explain how to apply validation rules
   - ‚úÖ Provide output templates from protocol
   - ‚ùå Don't just describe CLI parameters

3. **Validate Against Protocol**
   - ‚úÖ Include validation checklists from protocol
   - ‚úÖ Self-check steps for AI
   - ‚úÖ Clear compliance criteria
   - ‚ùå Don't rely on external validation only

**Quality Checklist**:
- [ ] Embeds protocol knowledge (entities, rules, constraints)
- [ ] Guides spec-compliant output production
- [ ] Includes validation rules from protocol
- [ ] Provides protocol-based templates
- [ ] AI can produce compliant output without external reference

---

#### Integration with Generated Speckit

These Slash Commands will:
1. Be generated into `templates/commands/` directory
2. Embed protocol knowledge from `specs/protocol/`
3. Guide AI to produce protocol-compliant outputs
4. Enable spec-driven development by AI agents

**This is the essence of Spec-Driven Toolkits**: Protocol knowledge embedded in execution guides.

\```

##### **Component 5: Generator (Optional)**

If applicable:

```markdown
### Generator Component

**Purpose**: Generate code/artifacts from validated specs

**Generation Targets**:
- {Target 1}: {Description}
- {Target 2}: {Description}

**Templates**:
- Location: `templates/`
- Format: Jinja2
- Customization: User-overridable

**API**:
```python
from {toolkit_name}.generator import generate

# Generate from spec
generate(spec, output_dir="./output", template="default")
```
\```

#### **Architecture Design**

```markdown
## Architecture

### Module Structure
```
{toolkit_name}/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ parser.py          # Parser component
‚îú‚îÄ‚îÄ validator.py       # Validator component
‚îú‚îÄ‚îÄ generator.py       # Generator component (optional)
‚îú‚îÄ‚îÄ cli.py             # CLI entry point
‚îú‚îÄ‚îÄ models.py          # Data models
‚îú‚îÄ‚îÄ exceptions.py      # Custom exceptions
‚îî‚îÄ‚îÄ templates/         # Templates (if generator exists)
```

### Data Flow
```
Input File
    ‚Üì
  Parser  ‚îÄ‚îÄ‚îÄ‚Üí Parsed Spec Object
    ‚Üì
Validator ‚îÄ‚îÄ‚îÄ‚Üí Validation Result
    ‚Üì
Generator ‚îÄ‚îÄ‚îÄ‚Üí Output Artifacts
```

### Key Classes
- `{Toolkit}Spec`: Main specification object
- `{Toolkit}Parser`: Parser implementation
- `{Toolkit}Validator`: Validator implementation
- `{Toolkit}Generator`: Generator implementation (optional)
\```

#### **Dependencies and Requirements**

```markdown
## Technical Requirements

### Language
- Python 3.9+

### Core Dependencies
- `pydantic`: Data validation and settings management
- `typer`: CLI framework
- `pyyaml` or `ruamel.yaml`: YAML parsing
- `jinja2`: Template engine (if generator)
- `rich`: Terminal formatting

### Development Dependencies
- `pytest`: Testing framework
- `mypy`: Type checking
- `ruff`: Linting and formatting
- `coverage`: Code coverage

### Optional Dependencies
- {Additional deps based on specific needs}
```

#### **Validation Strategy**

```markdown
## Validation Strategy

### Unit Tests
- Test each component independently
- Mock external dependencies
- Aim for 80%+ coverage

### Integration Tests
- Test component interactions
- Test CLI commands end-to-end
- Test with real specification files

### Validation Cases
1. **Parser Tests**:
   - Valid YAML/JSON parsing
   - Invalid syntax handling
   - Edge cases (empty files, large files)

2. **Validator Tests**:
   - Each validation rule from protocol spec
   - Error message quality
   - Multiple errors handling

3. **CLI Tests**:
   - Each command with various options
   - Error handling
   - Help messages

4. **Generator Tests** (if applicable):
   - Template rendering
   - Output file creation
   - Custom template handling

### Validation Data
- Sample valid specifications
- Sample invalid specifications
- Edge cases

**Validation Location**: `tests/` directory
```

#### **Success Criteria**

```markdown
## Success Criteria

### MVP Features
- ‚úÖ {Feature 1}
- ‚úÖ {Feature 2}
- ‚úÖ {Feature 3}

### Quality Metrics
- All tests pass
- 80%+ code coverage
- No critical linting errors
- Type hints complete (mypy passes)

### Documentation
- README with quickstart
- API documentation
- CLI help messages complete
- Example specifications

### User Experience
- Clear error messages
- Fast execution (< 1s for typical specs)
- Good CLI UX (progress bars, colors)
```

### 4. Write Specification File

**Location**: `specs/toolkit/{number}-{name}/spec.md`

**Structure**:
```markdown
# {Toolkit Name}

**Version**: {version}
**Status**: Draft | In Development | Stable
**Created**: {date}

## Dependencies

{Dependencies from step 3}

## Overview

{Overview from step 3}

## Components

{Component specifications from step 3}

## Architecture

{Architecture design from step 3}

## Technical Requirements

{Requirements from step 3}

## Validation Strategy

{Validation strategy from step 3}

## Success Criteria

{Success criteria from step 3}

## Implementation Plan

See `plan.md` (created via `/metaspec.sdd.plan`)

## Tasks

See `tasks.md` (created via `/metaspec.sdd.tasks`)
```

### 5. Success Output

```
‚úÖ Toolkit specification created/updated:

üìÅ Location:
   specs/toolkit/{number}-{name}/spec.md

üéØ Toolkit: {Toolkit Name} v{version}

üì¶ Dependencies:
   ‚Üí protocol/{dependency-1}
   ‚Üí protocol/{dependency-2}

üîß Components: {count} components defined
   - {Component 1}
   - {Component 2}
   ...

‚úì Architecture: Defined
‚úì Validation Strategy: Defined
‚úì Success Criteria: Defined

üîÑ Next steps:
1. Review toolkit specification
2. Run /metaspec.sdd.plan to create implementation plan
3. Run /metaspec.sdd.tasks to break down work
4. Run /metaspec.sdd.implement to start building
```

## Best Practices

### Toolkit Specification Focus

‚úÖ **DO**:
- Define HOW to implement the toolkit
- Specify Parser, Validator, CLI, Generator
- Reference protocol specs explicitly
- Include architecture and validation strategy
- Focus on user experience

‚ùå **DON'T**:
- Redefine the protocol (belongs in protocol specs)
- Skip dependency declarations
- Mix protocol and toolkit concerns
- Over-specify implementation details

### Dependency Management

- **Always** declare protocol dependencies at the top
- Reference specific protocol/XXX- specs
- Document which protocol features are supported
- Note version compatibility if relevant

### Component Design

- Keep components modular and testable
- Clear interfaces between components
- Minimal coupling
- Support both CLI and programmatic usage

### Progressive Enhancement

Start with MVP:
1. Parser (basic)
2. Validator (core rules)
3. CLI (init + validate)

Add later:
4. Generator
5. Advanced CLI features
6. SDK/Library enhancements

## Constitution Check

Before finalizing, verify against `memory/constitution.md`:

```bash
# Check toolkit spec against constitution
grep -A 5 "Minimal Viable Abstraction" memory/constitution.md
grep -A 5 "AI-First Design" memory/constitution.md
```

**Ensure**:
- Start with minimal viable toolkit
- Components are clearly defined
- Architecture supports extension
- Testing is built-in from start

## Troubleshooting

**If no protocol specs exist**:
‚Üí Prompt user to create protocol spec first with `/metaspec.sds.specify`

**If toolkit seems too complex**:
‚Üí Break into multiple toolkit specs (e.g., parser-only, validator-only)

**If unclear architecture**:
‚Üí Use `/metaspec.sdd.clarify` to resolve design questions

**If components overlap**:
‚Üí Review separation of concerns, consider merging or splitting

**If validation strategy unclear**:
‚Üí Focus on contract testing at component boundaries
