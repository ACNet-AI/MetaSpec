# Meta-Spec AI Agent Guide

> **For AI Assistants**: This document provides guidance on using Meta-Spec to generate Spec-Driven X (SD-X) speckits.

---

## ğŸ¯ Your Role

You are helping a developer create **speckits** (spec-driven toolkits for AI agents) using MetaSpec. 

MetaSpec is a meta-specification framework that generates complete Spec-Driven X (SD-X) speckits:
- **SD-Development** - Spec-driven development
- **SD-Design** - Spec-driven design systems
- **SD-Testing** - Spec-driven testing frameworks
- **SD-Documentation** - Spec-driven documentation
- **SD-Operations** - Spec-driven operations
- **SD-X** - Spec-driven generation for any domain

**Key principle**: MetaSpec generates production-ready speckits with CLI, parser, validator, templates, and AI agent support

---

## ğŸ’¡ Core Concept: Meta-Specification Framework

MetaSpec is a **meta-specification framework** - it uses specifications to generate specification toolkits.

```
Meta-Specification (MetaSpec)
        â†“
  Defines how to define specifications
        â†“
Generates Speckits (Spec-driven Toolkits)
        â†“
Speckits carry domain specifications
        â†“
Used to develop domain projects
```

### Key Insights

1. **Meta-level abstraction** - MetaSpec defines how to create specification systems
2. **Generative framework** - Generates complete speckits from meta-specifications
3. **Recursive architecture** - MetaSpec uses SDD to develop itself, generates speckits that use SDD
4. **Specification-centric** - Domain specs are the source of truth, speckits are carriers

**Example Flow**:
```
MetaSpec (meta-spec)
    â†“ generates
MCP-Spec-Kit (carries MCP protocol spec)
    â†“ used by
Developer (validates MCP servers against spec)
```

**This means**: MetaSpec is not just "spec-driven development" - it's a framework that **generates speckits** (spec-driven toolkits) for any domain.

**See [Recommended Practice: Two-Feature Architecture](#recommended-practice-two-feature-architecture) in MetaSpec Commands section for how speckits separate protocol specs from implementation.**

---

## ğŸ“‹ CLI Commands

MetaSpec provides these commands:

- `metaspec init [name]` - Create speckit (interactive or template-based)
- `metaspec search <query>` - Search community speckits
- `metaspec install <name>` - Install from community
- `metaspec contribute <name>` - Contribute to community
- `metaspec list` - List installed speckits  
- `metaspec info <name>` - Show speckit information

Use these commands in your workflow to help users create and discover speckits.

---

## ğŸ”’ Constitutional Principles

**ALWAYS follow** `memory/constitution.md` which defines:
- Core principles for meta-spec definitions
- Quality standards for generated systems
- Prohibited patterns
- Required patterns

**Key principles:**
1. **Minimal Viable Abstraction**: Don't over-abstract
2. **AI-First Design**: Generated systems must be AI-friendly
3. **Progressive Enhancement**: Start with MVP, add features incrementally
4. **Domain Specificity**: Respect domain constraints

---

## ğŸ¤ Spec-Driven Development for Speckits

Generated **speckits** (spec-driven toolkits) include **MetaSpec commands** in `.metaspec/commands/` to assist AI in understanding and generating the speckit.

**Speckits** are specialized toolkits generated by MetaSpec that:
- Carry domain specifications as core assets
- Include built-in MetaSpec commands for development
- Follow spec-driven architecture patterns

These commands provide a complete workflow from specification definition to controlled evolution (19 commands total: 8 SDS + 8 SDD + 3 Evolution).

See [MetaSpec Commands section](#-metaspec-commands-specification-lifecycle-management) for the complete command reference.

---

## ğŸ¯ MetaSpec Commands: Specification Lifecycle Management

When you generate a speckit, it includes MetaSpec (Spec-Driven X) commands in the `.metaspec/commands/` directory. These commands manage the **specification lifecycle**.

### Command Groups

MetaSpec uses a three-layer architecture to separate concerns:

#### SDS (Spec-Driven Specification) - 8 Commands
For defining domain protocol specifications:

- `/metaspec.sds.constitution` - Define protocol design principles
- `/metaspec.sds.specify` - Define protocol entities, operations, validation rules
- `/metaspec.sds.clarify` - Resolve ambiguities in protocol specification
- `/metaspec.sds.plan` - Plan protocol architecture and sub-specifications
- `/metaspec.sds.tasks` - Break down protocol specification work
- `/metaspec.sds.implement` - Write protocol specification documents
- `/metaspec.sds.checklist` - Generate quality checklist for protocol specification
- `/metaspec.sds.analyze` - Check protocol consistency

**Location**: Works with `specs/protocol/` directory

#### ğŸŒ³ Recursive Tree Structure (NEW)

**SDS supports recursive protocol hierarchy**:

```
001-order-protocol (root)
  â”œâ”€â”€ 002-order-creation (leaf)
  â”œâ”€â”€ 003-payment-processing (parent)
  â”‚     â”œâ”€â”€ 013-credit-card-payment (leaf)
  â”‚     â”œâ”€â”€ 014-digital-wallet-payment (leaf)
  â”‚     â””â”€â”€ 015-bank-transfer-payment (leaf)
  â””â”€â”€ 004-fulfillment (leaf)
```

**Key features**:
- **Any protocol can be a parent**: If complex, run plan â†’ tasks â†’ implement to create sub-protocols
- **Unlimited depth**: Sub-protocols can have their own sub-protocols
- **Context tracking**: Via YAML frontmatter (protocol_id, parent, root, type)
- **Unified commands**: Same commands work at all levels

**Example workflow** (Level 2 splitting):
```bash
# At root (001)
/metaspec.sds.specify â†’ 001-order-protocol/spec.md
/metaspec.sds.plan â†’ Decides to split
/metaspec.sds.implement â†’ Creates 002-008

# At level 2 (003 is also complex)
cd specs/protocol/003-payment-processing/
/metaspec.sds.plan â†’ Decides to split again
/metaspec.sds.implement â†’ Creates 013-015
```

**Protocol relationships**:
- **Parent â†’ Child**: Parent's spec.md lists sub-protocols in "Sub-Specifications" section
- **Child â†’ Parent**: Child's frontmatter declares `parent: {parent-id}`
- **Parent chain**: Tracked in frontmatter and displayed as breadcrumb

**See [Recommended Practice: Two-Feature Architecture](#recommended-practice-two-feature-architecture) for protocol + toolkit separation.**

---

#### âš ï¸ CRITICAL PRINCIPLE: Protocol First, Toolkit Second

**Every speckit MUST have a protocol specification before toolkit development.**

Why this matters:
- **Protocol** = WHAT (domain specification, core asset)
- **Toolkit** = HOW (implementation, supporting tool)
- Without protocol, MetaSpec becomes a generic code generator
- **Spec-Driven** means specifications drive development

**Workflow**:
1. âœ… First: Define protocol with `/metaspec.sds.specify`
2. âœ… Then: Develop toolkit with `/metaspec.sdd.specify`
3. âŒ Never: Skip protocol and go straight to toolkit

**Enforcement**:
- `/metaspec.sdd.specify` will ERROR if no protocol exists
- `/metaspec.sdd.analyze` marks missing protocol as CRITICAL
- Toolkit specs MUST have Dependencies section referencing protocol

---

### ğŸ¯ How Toolkit Value is Realized

**Toolkit value â‰  Fixed code templates**  
**Toolkit value = Spec-driven code generation**

MetaSpec generates **working toolkits** through a three-stage process:

#### Stage 1: Define Protocol (SDS)
```
/metaspec.sds.specify
  â†“
specs/protocol/001-{domain}-protocol/spec.md
  - Entity definitions
  - Validation rules
  - Operations
  - Error handling
```

#### Stage 2: Define Toolkit (SDD)
```
/metaspec.sdd.specify
  â†“
AI guides you to define:
  - Implementation Language: Python / TypeScript / Go / Rust / Other
  - Required Components: Parser / Validator / CLI / Generator / SDK
  - Architecture: Monolithic / Modular / Plugin-based
  â†“
specs/toolkit/001-{name}/spec.md
  - Language choice + rationale
  - Component selection
  - Architecture direction
  - Dependencies on protocol
```

#### Stage 3: Generate Code (SDD)
```
/metaspec.sdd.plan
  â†“
AI designs architecture based on:
  - Chosen language (Python/TS/Go/Rust)
  - Required components
  - Protocol entities
  â†“
specs/toolkit/001-{name}/plan.md
  - Tech stack for chosen language
  - File structure
  - Component interfaces
  
/metaspec.sdd.implement
  â†“
AI generates code based on:
  - Protocol spec (entity definitions)
  - Toolkit spec (language, components)
  - Plan (architecture, structure)
  â†“
src/{package_name}/
  - models.py/ts/go (from protocol entities)
  - parser.py/ts/go (from toolkit spec)
  - validator.py/ts/go (enforces protocol rules)
  - cli.py/ts/go (toolkit commands)
```

**Key advantages**:
- âœ… **Language-agnostic**: Supports Python, TypeScript, Go, Rust
- âœ… **Component-flexible**: Generate only what's needed
- âœ… **Architecture-adaptive**: Monolithic, modular, or plugin-based
- âœ… **Spec-driven**: Code generated from specifications, not templates
- âœ… **Protocol-compliant**: Generated code enforces protocol rules

**Example outcome**:
```bash
$ cd my-speckit
$ /metaspec.sds.specify  # Define MCP protocol
$ /metaspec.sdd.specify  # Choose Python, Parser+Validator+CLI
$ /metaspec.sdd.plan     # Design Python architecture
$ /metaspec.sdd.implement # Generate code
$ pip install -e .
$ my-speckit --help      # âœ… Working CLI!
$ my-speckit validate spec.yaml  # âœ… Validates against protocol!
```

This is how MetaSpec realizes Toolkit value: **not by providing fixed templates, but by generating spec-driven, language-appropriate, working code**.

#### SDD (Spec-Driven Development) - 8 Commands
For developing speckits (spec-driven toolkits):

- `/metaspec.sdd.constitution` - Define toolkit development principles
- `/metaspec.sdd.specify` - Define toolkit specifications
- `/metaspec.sdd.clarify` - Resolve toolkit ambiguities
- `/metaspec.sdd.plan` - Plan toolkit implementation
- `/metaspec.sdd.tasks` - Break down implementation work
- `/metaspec.sdd.implement` - Build toolkit code
- `/metaspec.sdd.checklist` - Validate quality
- `/metaspec.sdd.analyze` - Check consistency

**Location**: Works with `specs/toolkit/` directory

#### Evolution - 3 Shared Commands
For controlled specification evolution (both SDS and SDD):

- `/metaspec.proposal` - Propose changes with `--type sds|sdd` parameter
- `/metaspec.apply` - Apply approved changes
- `/metaspec.archive` - Archive completed changes

**Location**: Works with `changes/` directory (independent from specs/)

### The Relationship

```
MetaSpec commands (19 total):
  - SDS (8 commands)     â†’ Define protocol specifications (specs/protocol/)
  - SDD (8 commands)     â†’ Develop toolkits (specs/toolkit/)
  - Evolution (3 shared) â†’ Manage changes (changes/)
                              â†“
                    Project structure:
                    â”œâ”€â”€ specs/
                    â”‚   â”œâ”€â”€ protocol/   â† SDS manages
                    â”‚   â””â”€â”€ toolkit/    â† SDD manages
                    â””â”€â”€ changes/        â† Evolution manages (independent)
```

**Key principle**: Clear separation between protocol specification (SDS) and toolkit development (SDD), with shared evolution commands.

### When to Use Which

**Use SDS commands** (`/metaspec.sds.*`):
- Defining domain protocols from scratch
- Specifying protocol entities, operations, validation rules
- Creating protocol specifications independent of implementation
- Focus on WHAT the protocol is

**Use SDD commands** (`/metaspec.sdd.*`):
- Developing spec-driven toolkits
- Planning and implementing parsers, validators, CLI
- Building tools to support a protocol
- Focus on HOW to implement the toolkit

**Use Evolution commands** (`/metaspec.*`):
- Specification is stable and in use (protocol or toolkit)
- Changes need review or approval
- Want to track change history
- Controlled evolution for both SDS and SDD specs
- Use `--type sds` for protocol changes, `--type sdd` for toolkit changes

**Typical workflow**:
1. SDS: Define protocol specification (`/metaspec.sds.specify`)
2. SDD: Design toolkit to support it (`/metaspec.sdd.specify`, `/metaspec.sdd.plan`)
3. SDD: Implement toolkit (`/metaspec.sdd.tasks`, `/metaspec.sdd.implement`)
4. Evolution: Manage changes to either protocol or toolkit (`/metaspec.proposal --type sds|sdd`)

### Recommended Practice: SDS + SDD Separation

When using MetaSpec to develop a speckit, follow this two-phase approach:

#### Phase 1: Protocol Specification (SDS)

**Purpose**: Define the domain protocol, rules, and standards

**Location**: `specs/protocol/001-{domain}-protocol/`

**What to include**:
- Protocol entities and schemas
- Validation rules and constraints
- Operations and interfaces
- Error handling specifications

**Example**:
```markdown
# specs/protocol/001-mcp-core-protocol/spec.md

## MCP Protocol Specification

### Server Interface
- initialize: Server startup handshake
- tools/list: Enumerate available tools
- tools/call: Execute a specific tool

### Validation Rules
- Tool name must be unique
- inputSchema must be valid JSON Schema
```

**Key principle**: This is pure domain knowledge, independent of any speckit implementation.

#### Phase 2: Toolkit Specification (SDD)

**Purpose**: Define how to build tools to parse, validate, and enforce the protocol

**Location**: `specs/toolkit/001-{name}/`

**What to include**:
- Explicit dependency on protocol specs
- **User Journey Analysis** (ğŸ†• From Step 2.5)
  - Primary users (AI Agents vs Human Developers distribution)
  - Key usage scenarios (3-5 scenarios with User/Context/Goal/Pain Point)
  - Feature derivation from scenarios (P0/P1/P2 priority matrix)
  - Command design rationale (why each command exists)
  - Scenario coverage matrix
- Parser design (input formats)
- Validator logic (references protocol rules)
- CLI commands (init, validate, generate)
- **Slash Commands** (for AI agents)
- **Templates & Examples** (ğŸ†• From Component 6)
  - Templates directory structure (organized by specification system source)
  - Template mapping (library specs â†’ directories)
  - Entity templates (protocol entities â†’ template files)
  - Examples directory (basic/advanced/use-cases)
  - Implementation checklist
- Success criteria

**Example**:
```markdown
# specs/toolkit/001-mcp-parser/spec.md

## Dependencies
- Depends on: protocol/001-mcp-core-protocol

## User Journey Analysis
### Primary Users
- 80% AI Agents (Claude in Cursor)
- 20% Human Developers

### Key Scenarios
**Scenario 1**: AI Agent generates MCP server from natural language
- User: AI Agent
- Goal: Generate valid server definition
- Required Features: show-protocol command, get-template command, validate CLI

**Scenario 2**: Developer validates server definition manually
- User: Human Developer
- Goal: Verify server compliance
- Required Features: init, validate, docs

### Derived Features (P0)
- Protocol reference system: AI needs rules before generating (Scenarios: 1)
- Template system: Users need starting points (Scenarios: 1, 2)
- Validation CLI: Critical for both AI and developers (All scenarios)

### Command Design Rationale
- show-protocol: AI needs rules before generating â†’ Scenario 1
- validate: Critical for both AI and developers â†’ All scenarios
- init: Developer quick setup â†’ Scenario 2

## Components
1. Parser: Parse MCP server definitions
2. Validator: Verify compliance with protocol spec
3. CLI: mcp-spec-kit init|validate|generate

## Templates & Examples
### Templates Directory Structure
templates/
â”œâ”€â”€ generic/               # From library/generic
â”‚   â”œâ”€â”€ commands/
â”‚   â””â”€â”€ templates/
â”œâ”€â”€ spec-kit/              # From library/sdd/spec-kit
â”‚   â”œâ”€â”€ commands/
â”‚   â””â”€â”€ templates/
â””â”€â”€ mcp/                   # Custom (from protocol/001-mcp-protocol)
    â”œâ”€â”€ commands/
    â”‚   â”œâ”€â”€ show-protocol.md
    â”‚   â”œâ”€â”€ get-template.md
    â”‚   â””â”€â”€ validate-server.md
    â””â”€â”€ templates/
        â”œâ”€â”€ basic-server.yaml
        â””â”€â”€ advanced-server.yaml

### Examples Directory
examples/
â”œâ”€â”€ basic/
â”‚   â”œâ”€â”€ simple-server.yaml
â”‚   â””â”€â”€ README.md
â””â”€â”€ advanced/
    â”œâ”€â”€ full-featured-server.yaml
    â””â”€â”€ README.md
```

**Key principle**: Toolkit specs explicitly depend on protocol specs, derive features from user scenarios, and define HOW to implement the toolkit.

#### MetaSpec Workflow for SDS + SDD

```bash
# Phase 1: Protocol Specification (SDS)
/metaspec.sds.constitution  # Define protocol principles
/metaspec.sds.specify       # Create specs/protocol/001-{domain}-protocol/spec.md
/metaspec.sds.clarify       # Resolve protocol ambiguities
/metaspec.sds.plan          # Plan protocol architecture (if complex)
/metaspec.sds.tasks         # Break down specification work
/metaspec.sds.implement     # Write protocol specification documents
/metaspec.sds.checklist     # Generate quality checklist for protocol
/metaspec.sds.analyze       # Check protocol consistency

# Phase 2: Toolkit Specification (SDD)
/metaspec.sdd.constitution  # Define toolkit principles
/metaspec.sdd.specify       # Create specs/toolkit/001-parser/spec.md
                           # Must reference: protocol/001-{domain}-protocol
/metaspec.sdd.plan          # Plan toolkit architecture
/metaspec.sdd.tasks         # Break down implementation
/metaspec.sdd.implement     # Build src/ code based on toolkit spec
/metaspec.sdd.checklist     # Validate quality
/metaspec.sdd.analyze       # Verify toolkit references protocol correctly

# Evolution: Manage Changes
/metaspec.proposal "Add GraphQL" --type sds    # Propose protocol change
/metaspec.apply add-graphql                     # Apply approved change
/metaspec.archive add-graphql                   # Archive completed change
```

#### Why Separate?

1. **Clear separation of concerns**
   - Protocol experts define WHAT (SDS)
   - Toolkit experts define HOW (SDD)

2. **Reusable specifications**
   - Protocol specs can be published independently
   - Other tools can reference the same protocol spec

3. **Clean dependencies**
   - Toolkit explicitly depends on protocol
   - `/metaspec.sdd.analyze` can verify consistency

4. **Embodies MetaSpec philosophy**
   - Protocol spec is the source of truth
   - Toolkit is the carrier

#### When to Use

**Use SDS + SDD Separation** (Recommended):
- Domain has well-defined protocols (MCP, OpenAPI, GraphQL)
- Protocol specification can be useful independently
- Multiple toolkit implementations might exist

**Merge SDS and SDD** (Acceptable for simple cases):
- Very simple domain without formal protocols
- Toolkit is the only implementation
- No need for standalone protocol specification

### Practical Examples

**Example 1: Starting a new speckit**
```bash
cd my-speckit
# Phase 1: Define protocol
/metaspec.sds.constitution  # Define protocol principles
/metaspec.sds.specify "Define MCP protocol"  # Protocol entities
/metaspec.sds.checklist  # Generate quality checklist
/metaspec.sds.analyze  # Check protocol consistency

# Phase 2: Design toolkit
/metaspec.sdd.constitution  # Define toolkit principles
/metaspec.sdd.specify "Define MCP parser and validator"  # Toolkit spec
/metaspec.sdd.plan  # Architecture design
```

**Example 2: Iterating on protocol**
```bash
# Make changes to specs/protocol/001-*/spec.md
/metaspec.sds.clarify  # Resolve ambiguities
/metaspec.sds.checklist  # Validate protocol quality
/metaspec.sds.analyze  # Check consistency
```

**Example 3: Implementing toolkit**
```bash
/metaspec.sdd.tasks  # Break down work
/metaspec.sdd.implement  # Execute tasks
/metaspec.sdd.checklist  # Validate quality
```

**Example 4: Controlled evolution**
```bash
# For stable protocol or toolkit
/metaspec.proposal "Add GraphQL support" --type sds  # Protocol change
# Review and approve
/metaspec.apply <proposal-id>
/metaspec.archive <proposal-id>
```

---

## ğŸ”„ Using Commands with Iteration Support

**CRITICAL**: Validation/analysis commands (checklist, analyze, clarify) support **iteration modes** to preserve history and track progress.

### Understanding Iteration Modes

When you run a validation command and output already exists, you should ask the user which mode to use:

| Mode | Action | When to Use |
|------|--------|-------------|
| **update** (default) | Update scores/status, add Iteration N section | User says "re-run", "verify improvement", "check again" |
| **new** | Create new output (backup existing) | User says "start fresh", "regenerate" |
| **append** | Add supplementary output for different focus | User says "add another", "different aspect" |

### Default Interpretation Rules

**When user says**:
- âœ… "re-run checklist" â†’ **update** mode
- âœ… "re-run analyze" â†’ **update** mode
- âœ… "verify improvement" â†’ **update** mode
- âœ… "check quality again" â†’ **update** mode
- âš ï¸ "start fresh" â†’ **new** mode
- âš ï¸ "regenerate checklist" â†’ **new** mode
- ğŸ”µ "add another checklist" â†’ **append** mode

**Key principle**: Default to **update** mode unless user explicitly requests new/regenerate.

### Iteration Workflow Example

**Scenario**: User improves protocol based on checklist feedback

```bash
# Step 1: Initial validation
User: "Run checklist to validate protocol quality"
AI: /metaspec.sds.checklist

Output:
âœ… Checklist generated: comprehensive-quality.md

ğŸ“‹ Summary:
- CHK001: âŒ Missing field types
- CHK002: âŒ No validation rules
- CHK003: âš ï¸ Incomplete examples
Score: 33% (1/3 passing)

# Step 2: User fixes issues
User edits specs/protocol/001-mcp/spec.md
- Adds field types
- Adds validation rules

# Step 3: Re-validate (CRITICAL MOMENT)
User: "Re-run checklist to verify improvements"

AI recognizes:
- âœ… Checklist file exists
- âœ… User says "re-run... verify improvements"
- âœ… This means: update mode (not regenerate)

AI: /metaspec.sds.checklist (update mode)

Output:
âœ… Checklist updated: comprehensive-quality.md

ğŸ“Š Iteration 2 Summary:
- Items updated: 3/3
- Improved: 2 items (CHK001: âŒ â†’ âœ…, CHK002: âŒ â†’ âœ…)
- Still partial: 1 item (CHK003: âš ï¸)

ğŸ“ˆ Progress:
- Previous: 33% (1/3 passing)
- Current: 67% (2/3 passing)
- Improvement: +34%

ğŸ¯ Key improvements:
- CHK001: âŒ â†’ âœ… (field types now defined)
- CHK002: âŒ â†’ âœ… (validation rules added)

âš ï¸ Still needs work:
- CHK003: Examples incomplete (2/5 entities)
```

### What Gets Preserved in Update Mode

**Preserved**:
- âœ… All previous iteration records (Iteration 1, 2, 3...)
- âœ… Original checklist item IDs (CHK001, CHK002...)
- âœ… Evidence and detailed findings
- âœ… Category structure
- âœ… Progress history

**Updated**:
- âœ… Pass/Partial/Missing status (âŒ â†’ âš ï¸ â†’ âœ…)
- âœ… Evidence with new findings
- âœ… Overall scores and percentages

**Added**:
- âœ… New Iteration N section with date
- âœ… Progress comparison (before/after)
- âœ… List of improvements

### Best Practices for AI Agents

1. **Always check if output exists**
   ```bash
   Before running validation command:
   - Check: Does checklists/comprehensive-quality.md exist?
   - If YES: Ask user for mode (or infer from keywords)
   - If NO: Generate new
   ```

2. **Default to update mode**
   ```bash
   Unless user explicitly says "start fresh" or "regenerate":
   â†’ Always choose update mode
   â†’ This preserves valuable history
   ```

3. **Highlight improvements**
   ```bash
   In update mode, emphasize:
   - What improved: CHK001: âŒ â†’ âœ…
   - What's still needed: CHK003: âš ï¸
   - Overall progress: +34%
   ```

4. **Never silently overwrite**
   ```bash
   âŒ WRONG: Detect existing file â†’ Silently regenerate
   âœ… RIGHT: Detect existing file â†’ Ask mode â†’ Update with history
   ```

### When NOT to Use Iteration Modes

**Creation commands** (specify, implement, constitution):
- âŒ These create initial specs/code
- âŒ After creation, users edit directly
- âŒ No iteration tracking needed

**Execution commands** (tasks):
- âŒ These execute and mark complete
- âŒ Not validation-oriented
- âŒ Use Evolution for changes

### Evolution Layer vs Command Layer

**Command Layer** (checklist, analyze, clarify):
- Purpose: **Validate** specification quality (read-only)
- Output: checklists/quality.md, analysis/report.md
- Never modifies: spec.md
- Iteration: update/new/append modes

**Evolution Layer** (proposal, apply, archive):
- Purpose: **Modify** specifications (formal process)
- Output: changes/[id]/proposal.md, spec-delta.md
- Modifies: spec.md (after approval)
- When: Released toolkit OR breaking/major changes

See [Decision Guide](docs/evolution-guide.md) for when to use which.

---

## ğŸ“ Complete Workflow: Generating a Speckit

This section describes **how to generate a speckit** using `metaspec init`.

**Note**: This is different from **developing a speckit** (which uses MetaSpec commands and [Two-Feature Architecture](#recommended-practice-two-feature-architecture) practice).

### Two Workflows

| Workflow | Purpose | Commands |
|----------|---------|----------|
| **Generate Speckit** | Create initial speckit structure | `metaspec init` (this section) |
| **Develop Speckit** | Define specs and implement features | MetaSpec commands `/metaspec.*` |

Creating a speckit is more complex than building an application. Follow these steps carefully.

---

### **STEP 1: Understand Domain Requirements**

**Goal**: Research domain before designing.

**Key actions**:
1. Ask clarifying questions (domain, use case, users, existing tools)
2. Use `web_search` for standards and best practices
3. Identify key entities and relationships

**Checklist**:
- [ ] Domain thoroughly researched
- [ ] Key entities identified (1-3 core entities)
- [ ] Existing solutions studied
- [ ] Not assuming domain behavior

---

### **STEP 2: Design Entity Model**

**Goal**: Define core entities with minimal fields.

**Key principles**:
- Start minimal: 1-3 entities, 3-5 fields each
- Field types: `string`, `number`, `boolean`, `array`, `object`
- Only essential fields as `required: true`
- Every field needs a description

**Checklist**:
- [ ] Entities match domain research
- [ ] Field names clear and consistent
- [ ] Only essential fields required
- [ ] No over-engineering

---

### **STEP 3: Use Template or Interactive Mode**

**Recommended**: Use `metaspec init` with templates or interactive mode.

```bash
metaspec init                        # Interactive wizard
metaspec init my-toolkit             # Quick start (uses 'default')
metaspec init my-toolkit default     # Explicit (same as above)
```

**Required fields** (if manual):
- `name`, `version`, `domain`, `lifecycle`, `description`
- Entity definition (from STEP 2)
- Commands (init, validate, generate)
- Dependencies (pydantic, typer, yaml parser)

**Checklist**:
- [ ] All required fields filled
- [ ] Entity matches STEP 2 design
- [ ] Commands aligned with domain
- [ ] Dependencies specified

---

### **STEP 4: Preview with Dry-Run**

**Goal**: Test before generating.

```bash
metaspec init my-toolkit --dry-run
```

**Checklist**:
- [ ] File structure looks correct
- [ ] Entity names verified
- [ ] Dependencies confirmed
- [ ] No validation errors

---

### **STEP 5: Generate Speckit**

**Goal**: Generate the complete speckit.

```bash
metaspec init my-speckit -o ./my-speckit
```

**Post-generation**:
1. Verify files created successfully
2. Run init script if exists: `./scripts/init.sh`
3. Read generated README.md and AGENTS.md

**Checklist**:
- [ ] Generation completed without errors
- [ ] All expected files present
- [ ] README and AGENTS.md generated

---

### **STEP 6: Test the Speckit**

**Goal**: Verify speckit works.

```bash
cd my-speckit
pip install -e .
my-speckit --help
my-speckit init sample.yaml
my-speckit validate sample.yaml
```

**Checklist**:
- [ ] CLI commands work
- [ ] Help messages clear
- [ ] Sample spec validates
- [ ] Error messages helpful

---

## âš ï¸ Common Pitfalls

**Avoid these mistakes**:

1. **Over-Engineering** - Start with 1-3 entities, 3-5 fields each (not 20+ fields)
2. **Skipping Research** - Always use `web_search` to study domain standards
3. **No Dry-Run** - Always preview with `--dry-run` before generating
4. **Not Testing** - Test CLI commands after generation
5. **Ignoring Constitution** - Follow Minimal Viable Abstraction, AI-First Design, Progressive Enhancement

---

## ğŸ¯ Success Criteria

A successful speckit generation should:

- [ ] **Solves a real domain problem** - Not just a generic tool
- [ ] **Has clear entity model** - Entities match domain research
- [ ] **Follows minimal abstraction** - No over-engineering
- [ ] **Generates cleanly** - No errors during `metaspec init`
- [ ] **CLI works** - All commands functional
- [ ] **Has good docs** - README and AGENTS.md are clear
- [ ] **Includes constitution** - memory/constitution.md exists
- [ ] **Is testable** - Can create sample specs
- [ ] **Follows patterns** - Matches existing spec-driven tools

---

## ğŸ“š Additional Resources

- **Template**: `templates/meta-spec-template.yaml`
- **Examples**: `examples/` directory
- **Constitution**: `memory/constitution.md`
- **Docs**: `docs/` directory
