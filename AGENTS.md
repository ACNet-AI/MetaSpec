# Meta-Spec AI Agent Guide

> **For AI Assistants**: This document provides guidance on using Meta-Spec to generate Spec-Driven X (SD-X) speckits.

---

## üéØ Your Role

You are helping a developer create **speckits** (spec-driven toolkits for AI agents) using MetaSpec. 

MetaSpec is a meta-specification framework that generates complete Spec-Driven X (SD-X) speckits:
- **SD-Development** - Spec-driven development
- **SD-Design** - Spec-driven design systems
- **SD-Testing** - Spec-driven testing frameworks
- **SD-Documentation** - Spec-driven documentation
- **SD-Operations** - Spec-driven operations
- **SD-X** - Spec-driven generation for any domain

**Key principle**: MetaSpec generates production-ready speckits with CLI, parser, validator, templates, and AI agent support

---

## üí° Core Concept: Meta-Specification Framework

MetaSpec is a **meta-specification framework** - it uses specifications to generate specification toolkits.

```
Meta-Specification (MetaSpec)
        ‚Üì
  Defines how to define specifications
        ‚Üì
Generates Speckits (Spec-driven Toolkits)
        ‚Üì
Speckits carry domain specifications
        ‚Üì
Used to develop domain projects
```

### Key Insights

1. **Meta-level abstraction** - MetaSpec defines how to create specification systems
2. **Generative framework** - Generates complete speckits from meta-specifications
3. **Recursive architecture** - MetaSpec uses SDD to develop itself, generates speckits that use SDD
4. **Specification-centric** - Domain specs are the source of truth, speckits are carriers

**Example Flow**:
```
MetaSpec (meta-spec)
    ‚Üì generates
MCP-Spec-Kit (carries MCP protocol spec)
    ‚Üì used by
Developer (validates MCP servers against spec)
```

**This means**: MetaSpec is not just "spec-driven development" - it's a framework that **generates speckits** (spec-driven toolkits) for any domain.

**See [Recommended Practice: Two-Feature Architecture](#recommended-practice-two-feature-architecture) in MetaSpec Commands section for how speckits separate protocol specs from implementation.**

---

## üìã CLI Commands

MetaSpec provides these commands:

- `metaspec init [name]` - Create speckit (interactive or template-based)
- `metaspec search <query>` - Search community speckits
- `metaspec install <name>` - Install from community
- `metaspec contribute <name>` - Contribute to community
- `metaspec list` - List installed speckits  
- `metaspec info <name>` - Show speckit information

Use these commands in your workflow to help users create and discover speckits.

---

## üîí Constitutional Principles

**ALWAYS follow** `memory/constitution.md` which defines:
- Core principles for meta-spec definitions
- Quality standards for generated systems
- Prohibited patterns
- Required patterns

**Key principles:**
1. **Minimal Viable Abstraction**: Don't over-abstract
2. **AI-First Design**: Generated systems must be AI-friendly
3. **Progressive Enhancement**: Start with MVP, add features incrementally
4. **Domain Specificity**: Respect domain constraints

---

## ü§ù Spec-Driven Development for Speckits

Generated **speckits** (spec-driven toolkits) include **MetaSpec commands** in `.metaspec/commands/` to assist AI in understanding and generating the speckit.

**Speckits** are specialized toolkits generated by MetaSpec that:
- Carry domain specifications as core assets
- Include built-in MetaSpec commands for development
- Follow spec-driven architecture patterns

These commands provide a complete workflow from specification definition to controlled evolution (16 commands total).

See [MetaSpec Commands section](#-metaspec-commands-specification-lifecycle-management) for the complete command reference.

---

## üéØ MetaSpec Commands: Specification Lifecycle Management

When you generate a speckit, it includes MetaSpec (Spec-Driven X) commands in the `.metaspec/commands/` directory. These commands manage the **specification lifecycle**.

### Command Groups

MetaSpec uses a three-layer architecture to separate concerns:

#### SDS (Spec-Driven Specification) - 5 Commands
For defining domain protocol specifications:

- `/metaspec.sds.constitution` - Define protocol design principles
- `/metaspec.sds.specify` - Define protocol entities, operations, validation rules
- `/metaspec.sds.clarify` - Resolve ambiguities in protocol specification
- `/metaspec.sds.checklist` - Generate quality checklist for protocol specification
- `/metaspec.sds.analyze` - Check protocol consistency

**Location**: Works with `specs/protocol/` directory

#### ‚ö†Ô∏è CRITICAL PRINCIPLE: Protocol First, Toolkit Second

**Every speckit MUST have a protocol specification before toolkit development.**

Why this matters:
- **Protocol** = WHAT (domain specification, core asset)
- **Toolkit** = HOW (implementation, supporting tool)
- Without protocol, MetaSpec becomes a generic code generator
- **Spec-Driven** means specifications drive development

**Workflow**:
1. ‚úÖ First: Define protocol with `/metaspec.sds.specify`
2. ‚úÖ Then: Develop toolkit with `/metaspec.sdd.specify`
3. ‚ùå Never: Skip protocol and go straight to toolkit

**Enforcement**:
- `/metaspec.sdd.specify` will ERROR if no protocol exists
- `/metaspec.sdd.analyze` marks missing protocol as CRITICAL
- Toolkit specs MUST have Dependencies section referencing protocol

---

### üéØ How Toolkit Value is Realized

**Toolkit value ‚â† Fixed code templates**  
**Toolkit value = Spec-driven code generation**

MetaSpec generates **working toolkits** through a three-stage process:

#### Stage 1: Define Protocol (SDS)
```
/metaspec.sds.specify
  ‚Üì
specs/protocol/001-{domain}-protocol/spec.md
  - Entity definitions
  - Validation rules
  - Operations
  - Error handling
```

#### Stage 2: Define Toolkit (SDD)
```
/metaspec.sdd.specify
  ‚Üì
AI guides you to define:
  - Implementation Language: Python / TypeScript / Go / Rust / Other
  - Required Components: Parser / Validator / CLI / Generator / SDK
  - Architecture: Monolithic / Modular / Plugin-based
  ‚Üì
specs/toolkit/001-{name}/spec.md
  - Language choice + rationale
  - Component selection
  - Architecture direction
  - Dependencies on protocol
```

#### Stage 3: Generate Code (SDD)
```
/metaspec.sdd.plan
  ‚Üì
AI designs architecture based on:
  - Chosen language (Python/TS/Go/Rust)
  - Required components
  - Protocol entities
  ‚Üì
specs/toolkit/001-{name}/plan.md
  - Tech stack for chosen language
  - File structure
  - Component interfaces
  
/metaspec.sdd.implement
  ‚Üì
AI generates code based on:
  - Protocol spec (entity definitions)
  - Toolkit spec (language, components)
  - Plan (architecture, structure)
  ‚Üì
src/{package_name}/
  - models.py/ts/go (from protocol entities)
  - parser.py/ts/go (from toolkit spec)
  - validator.py/ts/go (enforces protocol rules)
  - cli.py/ts/go (toolkit commands)
```

**Key advantages**:
- ‚úÖ **Language-agnostic**: Supports Python, TypeScript, Go, Rust
- ‚úÖ **Component-flexible**: Generate only what's needed
- ‚úÖ **Architecture-adaptive**: Monolithic, modular, or plugin-based
- ‚úÖ **Spec-driven**: Code generated from specifications, not templates
- ‚úÖ **Protocol-compliant**: Generated code enforces protocol rules

**Example outcome**:
```bash
$ cd my-speckit
$ /metaspec.sds.specify  # Define MCP protocol
$ /metaspec.sdd.specify  # Choose Python, Parser+Validator+CLI
$ /metaspec.sdd.plan     # Design Python architecture
$ /metaspec.sdd.implement # Generate code
$ pip install -e .
$ my-speckit --help      # ‚úÖ Working CLI!
$ my-speckit validate spec.yaml  # ‚úÖ Validates against protocol!
```

This is how MetaSpec realizes Toolkit value: **not by providing fixed templates, but by generating spec-driven, language-appropriate, working code**.

#### SDD (Spec-Driven Development) - 8 Commands
For developing speckits (spec-driven toolkits):

- `/metaspec.sdd.constitution` - Define toolkit development principles
- `/metaspec.sdd.specify` - Define toolkit specifications
- `/metaspec.sdd.clarify` - Resolve toolkit ambiguities
- `/metaspec.sdd.plan` - Plan toolkit implementation
- `/metaspec.sdd.tasks` - Break down implementation work
- `/metaspec.sdd.implement` - Build toolkit code
- `/metaspec.sdd.checklist` - Validate quality
- `/metaspec.sdd.analyze` - Check consistency

**Location**: Works with `specs/toolkit/` directory

#### Evolution - 3 Shared Commands
For controlled specification evolution (both SDS and SDD):

- `/metaspec.proposal` - Propose changes with `--type sds|sdd` parameter
- `/metaspec.apply` - Apply approved changes
- `/metaspec.archive` - Archive completed changes

**Location**: Works with `changes/` directory (independent from specs/)

### The Relationship

```
MetaSpec commands (16 total):
  - SDS (5 commands)     ‚Üí Define protocol specifications (specs/protocol/)
  - SDD (8 commands)     ‚Üí Develop toolkits (specs/toolkit/)
  - Evolution (3 shared) ‚Üí Manage changes (changes/)
                              ‚Üì
                    Project structure:
                    ‚îú‚îÄ‚îÄ specs/
                    ‚îÇ   ‚îú‚îÄ‚îÄ protocol/   ‚Üê SDS manages
                    ‚îÇ   ‚îî‚îÄ‚îÄ toolkit/    ‚Üê SDD manages
                    ‚îî‚îÄ‚îÄ changes/        ‚Üê Evolution manages (independent)
```

**Key principle**: Clear separation between protocol specification (SDS) and toolkit development (SDD), with shared evolution commands.

### When to Use Which

**Use SDS commands** (`/metaspec.sds.*`):
- Defining domain protocols from scratch
- Specifying protocol entities, operations, validation rules
- Creating protocol specifications independent of implementation
- Focus on WHAT the protocol is

**Use SDD commands** (`/metaspec.sdd.*`):
- Developing spec-driven toolkits
- Planning and implementing parsers, validators, CLI
- Building tools to support a protocol
- Focus on HOW to implement the toolkit

**Use Evolution commands** (`/metaspec.*`):
- Specification is stable and in use (protocol or toolkit)
- Changes need review or approval
- Want to track change history
- Controlled evolution for both SDS and SDD specs
- Use `--type sds` for protocol changes, `--type sdd` for toolkit changes

**Typical workflow**:
1. SDS: Define protocol specification (`/metaspec.sds.specify`)
2. SDD: Design toolkit to support it (`/metaspec.sdd.specify`, `/metaspec.sdd.plan`)
3. SDD: Implement toolkit (`/metaspec.sdd.tasks`, `/metaspec.sdd.implement`)
4. Evolution: Manage changes to either protocol or toolkit (`/metaspec.proposal --type sds|sdd`)

### Recommended Practice: SDS + SDD Separation

When using MetaSpec to develop a speckit, follow this two-phase approach:

#### Phase 1: Protocol Specification (SDS)

**Purpose**: Define the domain protocol, rules, and standards

**Location**: `specs/protocol/001-{domain}-protocol/`

**What to include**:
- Protocol entities and schemas
- Validation rules and constraints
- Operations and interfaces
- Error handling specifications

**Example**:
```markdown
# specs/protocol/001-mcp-core-protocol/spec.md

## MCP Protocol Specification

### Server Interface
- initialize: Server startup handshake
- tools/list: Enumerate available tools
- tools/call: Execute a specific tool

### Validation Rules
- Tool name must be unique
- inputSchema must be valid JSON Schema
```

**Key principle**: This is pure domain knowledge, independent of any speckit implementation.

#### Phase 2: Toolkit Specification (SDD)

**Purpose**: Define how to build tools to parse, validate, and enforce the protocol

**Location**: `specs/toolkit/001-{name}/`

**What to include**:
- Explicit dependency on protocol specs
- Parser design (input formats)
- Validator logic (references protocol rules)
- CLI commands (init, validate, generate)
- Success criteria

**Example**:
```markdown
# specs/toolkit/001-mcp-parser/spec.md

## Dependencies
- Depends on: protocol/001-mcp-core-protocol

## Components
1. Parser: Parse MCP server definitions
2. Validator: Verify compliance with protocol spec
3. CLI: mcp-spec-kit init|validate|generate
```

**Key principle**: Toolkit specs explicitly depend on protocol specs and define HOW to implement the toolkit.

#### MetaSpec Workflow for SDS + SDD

```bash
# Phase 1: Protocol Specification (SDS)
/metaspec.sds.constitution  # Define protocol principles
/metaspec.sds.specify       # Create specs/protocol/001-{domain}-protocol/spec.md
/metaspec.sds.clarify       # Resolve protocol ambiguities
/metaspec.sds.checklist     # Generate quality checklist for protocol
/metaspec.sds.analyze       # Check protocol consistency

# Phase 2: Toolkit Specification (SDD)
/metaspec.sdd.constitution  # Define toolkit principles
/metaspec.sdd.specify       # Create specs/toolkit/001-parser/spec.md
                           # Must reference: protocol/001-{domain}-protocol
/metaspec.sdd.plan          # Plan toolkit architecture
/metaspec.sdd.tasks         # Break down implementation
/metaspec.sdd.implement     # Build src/ code based on toolkit spec
/metaspec.sdd.checklist     # Validate quality
/metaspec.sdd.analyze       # Verify toolkit references protocol correctly

# Evolution: Manage Changes
/metaspec.proposal "Add GraphQL" --type sds    # Propose protocol change
/metaspec.apply add-graphql                     # Apply approved change
/metaspec.archive add-graphql                   # Archive completed change
```

#### Why Separate?

1. **Clear separation of concerns**
   - Protocol experts define WHAT (SDS)
   - Toolkit experts define HOW (SDD)

2. **Reusable specifications**
   - Protocol specs can be published independently
   - Other tools can reference the same protocol spec

3. **Clean dependencies**
   - Toolkit explicitly depends on protocol
   - `/metaspec.sdd.analyze` can verify consistency

4. **Embodies MetaSpec philosophy**
   - Protocol spec is the source of truth
   - Toolkit is the carrier

#### When to Use

**Use SDS + SDD Separation** (Recommended):
- Domain has well-defined protocols (MCP, OpenAPI, GraphQL)
- Protocol specification can be useful independently
- Multiple toolkit implementations might exist

**Merge SDS and SDD** (Acceptable for simple cases):
- Very simple domain without formal protocols
- Toolkit is the only implementation
- No need for standalone protocol specification

### Practical Examples

**Example 1: Starting a new speckit**
```bash
cd my-speckit
# Phase 1: Define protocol
/metaspec.sds.constitution  # Define protocol principles
/metaspec.sds.specify "Define MCP protocol"  # Protocol entities
/metaspec.sds.checklist  # Generate quality checklist
/metaspec.sds.analyze  # Check protocol consistency

# Phase 2: Design toolkit
/metaspec.sdd.constitution  # Define toolkit principles
/metaspec.sdd.specify "Define MCP parser and validator"  # Toolkit spec
/metaspec.sdd.plan  # Architecture design
```

**Example 2: Iterating on protocol**
```bash
# Make changes to specs/protocol/001-*/spec.md
/metaspec.sds.clarify  # Resolve ambiguities
/metaspec.sds.checklist  # Validate protocol quality
/metaspec.sds.analyze  # Check consistency
```

**Example 3: Implementing toolkit**
```bash
/metaspec.sdd.tasks  # Break down work
/metaspec.sdd.implement  # Execute tasks
/metaspec.sdd.checklist  # Validate quality
```

**Example 4: Controlled evolution**
```bash
# For stable protocol or toolkit
/metaspec.proposal "Add GraphQL support" --type sds  # Protocol change
# Review and approve
/metaspec.apply <proposal-id>
/metaspec.archive <proposal-id>
```

---

## üîÑ Using Commands with Iteration Support

**CRITICAL**: Validation/analysis commands (checklist, analyze, clarify) support **iteration modes** to preserve history and track progress.

### Understanding Iteration Modes

When you run a validation command and output already exists, you should ask the user which mode to use:

| Mode | Action | When to Use |
|------|--------|-------------|
| **update** (default) | Update scores/status, add Iteration N section | User says "re-run", "verify improvement", "check again" |
| **new** | Create new output (backup existing) | User says "start fresh", "regenerate" |
| **append** | Add supplementary output for different focus | User says "add another", "different aspect" |

### Default Interpretation Rules

**When user says**:
- ‚úÖ "re-run checklist" ‚Üí **update** mode
- ‚úÖ "re-run analyze" ‚Üí **update** mode
- ‚úÖ "verify improvement" ‚Üí **update** mode
- ‚úÖ "check quality again" ‚Üí **update** mode
- ‚ö†Ô∏è "start fresh" ‚Üí **new** mode
- ‚ö†Ô∏è "regenerate checklist" ‚Üí **new** mode
- üîµ "add another checklist" ‚Üí **append** mode

**Key principle**: Default to **update** mode unless user explicitly requests new/regenerate.

### Iteration Workflow Example

**Scenario**: User improves protocol based on checklist feedback

```bash
# Step 1: Initial validation
User: "Run checklist to validate protocol quality"
AI: /metaspec.sds.checklist

Output:
‚úÖ Checklist generated: comprehensive-quality.md

üìã Summary:
- CHK001: ‚ùå Missing field types
- CHK002: ‚ùå No validation rules
- CHK003: ‚ö†Ô∏è Incomplete examples
Score: 33% (1/3 passing)

# Step 2: User fixes issues
User edits specs/protocol/001-mcp/spec.md
- Adds field types
- Adds validation rules

# Step 3: Re-validate (CRITICAL MOMENT)
User: "Re-run checklist to verify improvements"

AI recognizes:
- ‚úÖ Checklist file exists
- ‚úÖ User says "re-run... verify improvements"
- ‚úÖ This means: update mode (not regenerate)

AI: /metaspec.sds.checklist (update mode)

Output:
‚úÖ Checklist updated: comprehensive-quality.md

üìä Iteration 2 Summary:
- Items updated: 3/3
- Improved: 2 items (CHK001: ‚ùå ‚Üí ‚úÖ, CHK002: ‚ùå ‚Üí ‚úÖ)
- Still partial: 1 item (CHK003: ‚ö†Ô∏è)

üìà Progress:
- Previous: 33% (1/3 passing)
- Current: 67% (2/3 passing)
- Improvement: +34%

üéØ Key improvements:
- CHK001: ‚ùå ‚Üí ‚úÖ (field types now defined)
- CHK002: ‚ùå ‚Üí ‚úÖ (validation rules added)

‚ö†Ô∏è Still needs work:
- CHK003: Examples incomplete (2/5 entities)
```

### What Gets Preserved in Update Mode

**Preserved**:
- ‚úÖ All previous iteration records (Iteration 1, 2, 3...)
- ‚úÖ Original checklist item IDs (CHK001, CHK002...)
- ‚úÖ Evidence and detailed findings
- ‚úÖ Category structure
- ‚úÖ Progress history

**Updated**:
- ‚úÖ Pass/Partial/Missing status (‚ùå ‚Üí ‚ö†Ô∏è ‚Üí ‚úÖ)
- ‚úÖ Evidence with new findings
- ‚úÖ Overall scores and percentages

**Added**:
- ‚úÖ New Iteration N section with date
- ‚úÖ Progress comparison (before/after)
- ‚úÖ List of improvements

### Best Practices for AI Agents

1. **Always check if output exists**
   ```bash
   Before running validation command:
   - Check: Does checklists/comprehensive-quality.md exist?
   - If YES: Ask user for mode (or infer from keywords)
   - If NO: Generate new
   ```

2. **Default to update mode**
   ```bash
   Unless user explicitly says "start fresh" or "regenerate":
   ‚Üí Always choose update mode
   ‚Üí This preserves valuable history
   ```

3. **Highlight improvements**
   ```bash
   In update mode, emphasize:
   - What improved: CHK001: ‚ùå ‚Üí ‚úÖ
   - What's still needed: CHK003: ‚ö†Ô∏è
   - Overall progress: +34%
   ```

4. **Never silently overwrite**
   ```bash
   ‚ùå WRONG: Detect existing file ‚Üí Silently regenerate
   ‚úÖ RIGHT: Detect existing file ‚Üí Ask mode ‚Üí Update with history
   ```

### When NOT to Use Iteration Modes

**Creation commands** (specify, implement, constitution):
- ‚ùå These create initial specs/code
- ‚ùå After creation, users edit directly
- ‚ùå No iteration tracking needed

**Execution commands** (tasks):
- ‚ùå These execute and mark complete
- ‚ùå Not validation-oriented
- ‚ùå Use Evolution for changes

### Evolution Layer vs Command Layer

**Command Layer** (checklist, analyze, clarify):
- Purpose: **Validate** specification quality (read-only)
- Output: checklists/quality.md, analysis/report.md
- Never modifies: spec.md
- Iteration: update/new/append modes

**Evolution Layer** (proposal, apply, archive):
- Purpose: **Modify** specifications (formal process)
- Output: changes/[id]/proposal.md, spec-delta.md
- Modifies: spec.md (after approval)
- When: Released toolkit OR breaking/major changes

See [Decision Guide](docs/evolution-guide.md) for when to use which.

---

## üìù Complete Workflow: Generating a Speckit

This section describes **how to generate a speckit** using `metaspec init`.

**Note**: This is different from **developing a speckit** (which uses MetaSpec commands and [Two-Feature Architecture](#recommended-practice-two-feature-architecture) practice).

### Two Workflows

| Workflow | Purpose | Commands |
|----------|---------|----------|
| **Generate Speckit** | Create initial speckit structure | `metaspec init` (this section) |
| **Develop Speckit** | Define specs and implement features | MetaSpec commands `/metaspec.*` |

Creating a speckit is more complex than building an application. Follow these steps carefully.

---

### **STEP 1: Understand Domain Requirements**

**Goal**: Research domain before designing.

**Key actions**:
1. Ask clarifying questions (domain, use case, users, existing tools)
2. Use `web_search` for standards and best practices
3. Identify key entities and relationships

**Checklist**:
- [ ] Domain thoroughly researched
- [ ] Key entities identified (1-3 core entities)
- [ ] Existing solutions studied
- [ ] Not assuming domain behavior

---

### **STEP 2: Design Entity Model**

**Goal**: Define core entities with minimal fields.

**Key principles**:
- Start minimal: 1-3 entities, 3-5 fields each
- Field types: `string`, `number`, `boolean`, `array`, `object`
- Only essential fields as `required: true`
- Every field needs a description

**Checklist**:
- [ ] Entities match domain research
- [ ] Field names clear and consistent
- [ ] Only essential fields required
- [ ] No over-engineering

---

### **STEP 3: Use Template or Interactive Mode**

**Recommended**: Use `metaspec init` with templates or interactive mode.

```bash
metaspec init                        # Interactive wizard
metaspec init my-toolkit --template default  # Quick start
```

**Required fields** (if manual):
- `name`, `version`, `domain`, `lifecycle`, `description`
- Entity definition (from STEP 2)
- Commands (init, validate, generate)
- Dependencies (pydantic, typer, yaml parser)

**Checklist**:
- [ ] All required fields filled
- [ ] Entity matches STEP 2 design
- [ ] Commands aligned with domain
- [ ] Dependencies specified

---

### **STEP 4: Preview with Dry-Run**

**Goal**: Test before generating.

```bash
metaspec init my-toolkit --template default --dry-run
```

**Checklist**:
- [ ] File structure looks correct
- [ ] Entity names verified
- [ ] Dependencies confirmed
- [ ] No validation errors

---

### **STEP 5: Generate Speckit**

**Goal**: Generate the complete speckit.

```bash
metaspec init my-speckit --template default -o ./my-speckit
```

**Post-generation**:
1. Verify files created successfully
2. Run init script if exists: `./scripts/init.sh`
3. Read generated README.md and AGENTS.md

**Checklist**:
- [ ] Generation completed without errors
- [ ] All expected files present
- [ ] README and AGENTS.md generated

---

### **STEP 6: Test the Speckit**

**Goal**: Verify speckit works.

```bash
cd my-speckit
pip install -e .
my-speckit --help
my-speckit init sample.yaml
my-speckit validate sample.yaml
```

**Checklist**:
- [ ] CLI commands work
- [ ] Help messages clear
- [ ] Sample spec validates
- [ ] Error messages helpful

---

## ‚ö†Ô∏è Common Pitfalls

**Avoid these mistakes**:

1. **Over-Engineering** - Start with 1-3 entities, 3-5 fields each (not 20+ fields)
2. **Skipping Research** - Always use `web_search` to study domain standards
3. **No Dry-Run** - Always preview with `--dry-run` before generating
4. **Not Testing** - Test CLI commands after generation
5. **Ignoring Constitution** - Follow Minimal Viable Abstraction, AI-First Design, Progressive Enhancement

---

## üéØ Success Criteria

A successful speckit generation should:

- [ ] **Solves a real domain problem** - Not just a generic tool
- [ ] **Has clear entity model** - Entities match domain research
- [ ] **Follows minimal abstraction** - No over-engineering
- [ ] **Generates cleanly** - No errors during `metaspec init`
- [ ] **CLI works** - All commands functional
- [ ] **Has good docs** - README and AGENTS.md are clear
- [ ] **Includes constitution** - memory/constitution.md exists
- [ ] **Is testable** - Can create sample specs
- [ ] **Follows patterns** - Matches existing spec-driven tools

---

## üìö Additional Resources

- **Template**: `templates/meta-spec-template.yaml`
- **Examples**: `examples/` directory
- **Constitution**: `memory/constitution.md`
- **Docs**: `docs/` directory
