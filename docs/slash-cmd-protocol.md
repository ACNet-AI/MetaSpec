# Slash Command Template Protocol

> **Version**: 1.0  
> **Status**: Draft  
> **Purpose**: Define the standard format for slash command systems in spec-driven toolkits

---

## ğŸ¯ Overview

This protocol defines the **dual-layer architecture** for slash command systems in spec-driven toolkits generated by MetaSpec.

### Key Principles

1. **All slash commands generate Spec documents** - Not code files
2. **All output goes to `specs/` directory** - Following Spec-Kit pattern
3. **Dual-layer structure** - Commands (instructions) + Templates (formats)
4. **Consistent structure** - For AI predictability
5. **Domain-agnostic by default** - Can be extended for specific domains

---

## ğŸ—ï¸ Dual-Layer Architecture

A complete slash command system consists of TWO layers:

```
slash-command-system/
â”œâ”€â”€ commands/              # Layer 1: AI Instructions
â”‚   â””â”€â”€ command.md.j2     # HOW to execute the command
â””â”€â”€ templates/             # Layer 2: Output Formats
    â””â”€â”€ output-template.md.j2  # WHAT format to generate
```

### Layer 1: Command Instructions

**Purpose**: Tell AI agents HOW to execute a workflow.

**Location**: 
- MetaSpec: `library/commands/` or `meta/commands/`
- Generated: `.cursor/commands/` or project-specific command directories

**Content**: Long-form instructions including:
- Context and background
- Step-by-step execution guide
- Reference to output templates
- Principles to follow
- Examples (optional)

### Layer 2: Output Templates

**Purpose**: Define WHAT format AI should generate.

**Location**:
- MetaSpec: `library/templates/` or `meta/templates/`
- Generated: `templates/` in toolkit or project

**Content**: Structured document skeleton with:
- Metadata section
- Clear section markers
- Placeholder content
- Variable interpolation
- Consistent formatting

### Relationship

```
User runs: /toolkit:plan "Add feature"
           â†“
AI reads:  .cursor/commands/plan.md
           (Layer 1: Instructions)
           â†“
AI uses:   templates/plan-template.md
           (Layer 2: Format)
           â†“
AI generates: specs/plan.md
              (Output)
```

---

## ğŸ“‹ Layer 1: Command Instruction Structure

Command files (`commands/*.md.j2`) provide detailed instructions for AI agents.

### Standard Structure

```markdown
# [Command Name] Command

[Brief description of what this command does]

## Usage

```
/[toolkit]:[command] "input description"
```

## Instructions

You are an AI assistant helping to [accomplish what].

### Context

- **Project**: {{ name }}
- **Domain**: {{ domain }}
- **Entity**: {{ entity.name }}

[Additional context specific to this command]

### Your Task

[Clear statement of what AI should accomplish]

### Steps

1. **[Step 1 Title]**
   - Detail 1
   - Detail 2

2. **[Step 2 Title]**
   - Detail 1
   - Detail 2

[Continue with numbered steps...]

### Template Reference

Follow the structure defined in `templates/[template-name].md`:
- [Key section 1]
- [Key section 2]
- [Key section 3]

### Principles

[Guidelines and principles to follow]

{% if description %}
{{ description }}
{% endif %}

Follow the constitution principles in `memory/constitution.md`.

### Next Steps

After completing this task, suggest running:
```
/[toolkit]:[next-command] "..."
```
```

### Optional Sections

**For complex concepts** (typically in metaspec):
```markdown
### Understanding [Concept]

[Detailed explanation of domain-specific concepts]

Example:
- What is an Entity?
- What is a Workflow?
- What is Validation?
```

**For best practices** (typically in metaspec):
```markdown
### Examples

#### âœ… Good Example
```
[Show good practice]
```

#### âŒ Bad Example
```
[Show what to avoid]
```

[Explanation of why]
```

### Variables Available

All command files have access to:
- `{{ name }}` - Toolkit name
- `{{ package_name }}` - Python package name
- `{{ domain }}` - Domain (generic, mcp, testing, etc.)
- `{{ description }}` - Toolkit description
- `{{ entity.name }}` - Entity name
- `{{ entity.fields }}` - Entity fields list
- `{{ date }}` - Current date

---

## ğŸ“„ Layer 2: Output Template Structure

Template files (`templates/*-template.md.j2`) define the format of generated documents.

```markdown
# [Document Title]

**[Metadata Section]**
- Version
- Created date
- Status
- Related entities/features

---

## ğŸ“‹ [Section 1: Context/Overview]
[Provide context and purpose]

---

## ğŸ¯ [Section 2: Requirements/Objectives]
[Define what needs to be achieved]

---

## ğŸ—ï¸ [Section 3: Design/Approach]
[Technical design or implementation approach]

### Data Model (if applicable)
```yaml
{{ entity.name | lower }}:
{% for field in entity.fields %}
  {{ field.name }}: {{ field.type }}  # {{ field.description }}
{% endfor %}
```

---

## ğŸ“ [Section 4: Structure/Organization]
[File structure, components, modules]

---

## ğŸ”„ [Section 5: Implementation Steps]
- [ ] Step 1
- [ ] Step 2
- [ ] Step 3

---

## âœ… [Section 6: Success Criteria/Checklist]
- [ ] Criterion 1
- [ ] Criterion 2

---

## ğŸ“š References
- [Link to related specs]
- [Link to constitution]
- [Link to other documents]

---

**Next Steps**: [Suggest next slash command to run]
```

---

## ğŸ¨ Template Variables

All templates have access to these standard variables:

### From MetaSpecDefinition
```jinja2
{{ name }}              # Toolkit name (e.g., "api-test-kit")
{{ package_name }}      # Package name (e.g., "api_test_kit")
{{ version }}           # Version (e.g., "0.1.0")
{{ domain }}            # Domain (e.g., "testing")
{{ description }}       # Toolkit description

{{ entity.name }}       # Entity name (e.g., "APITest")
{{ entity.fields }}     # List of EntityField objects
```

### Runtime Variables
```jinja2
{{ date }}              # Current date (YYYY-MM-DD)
{{ timestamp }}         # Current timestamp
```

### Custom Variables
Templates can define custom variables in their frontmatter or accept them via AI input.

---

## ğŸ“¦ Official Template Pool

MetaSpec provides these official templates in its internal `library/`:

| Template | Purpose | Output |
|----------|---------|--------|
| `plan-template.md.j2` | Implementation planning | `specs/plan.md` |
| `tasks-template.md.j2` | Task breakdown | `specs/tasks.md` |
| `checklist-template.md.j2` | Quality checklist | `specs/checklist.md` |
| `spec-template.md.j2` | Specification document | `specs/spec.md` |

When MetaSpec generates a toolkit, these templates are copied to the toolkit's `templates/` directory (without the `library/` prefix).

### Using Templates in Generated Toolkits

Toolkit developers see a flat structure:

```
my-toolkit/
â””â”€â”€ templates/               # All templates in one place
    â”œâ”€â”€ plan-template.md
    â”œâ”€â”€ tasks-template.md
    â”œâ”€â”€ checklist-template.md
    â””â”€â”€ spec-template.md
```

**Option 1: Use existing templates**
```yaml
# In MetaSpecDefinition
slash_commands:
  - name: "plan"
    description: "Generate implementation plan"
    template: "templates/plan-template.md.j2"  # Use provided template
```

**Option 2: Add custom templates**
```yaml
slash_commands:
  - name: "api-design"
    description: "Design API specification"
    template: "templates/api-design-template.md.j2"  # Custom template
```

All templates in the `templates/` directory follow the same protocol - no distinction needed.

---

## ğŸ”§ Template Generation Flow

```
1. User runs slash command in AI editor
   /my-toolkit:plan "Add user authentication"

2. AI reads command instructions
   .cursor/commands/plan.md

3. AI references output template
   templates/plan-template.md

4. AI renders content with context
   - MetaSpecDefinition variables
   - User input ("Add user authentication")
   - Current project state

5. AI outputs to specs/
   specs/plan.md
```

---

## âœ… Requirements

### Command Requirements (Layer 1)

Every command instruction file MUST:

- [ ] Have clear title and description
- [ ] Include Usage section with example
- [ ] Provide Context with project/entity info
- [ ] Define clear Task statement
- [ ] List specific Steps to follow
- [ ] Reference appropriate output template
- [ ] Include Principles or guidelines
- [ ] Suggest Next Steps

Every command instruction file SHOULD:

- [ ] Explain complex concepts (for metaspec commands)
- [ ] Provide good/bad examples (for best practices)
- [ ] Be specific and actionable
- [ ] Reference constitution principles
- [ ] Be concise but complete

### Template Requirements (Layer 2)

Every output template file MUST:

- [ ] Follow the standard structure defined above
- [ ] Include metadata section (version, date, status)
- [ ] Have clear section markers (`## ğŸ“‹`, `## ğŸ¯`, etc.)
- [ ] Reference entity model if applicable
- [ ] Include success criteria or checklist
- [ ] Link to related documents
- [ ] Suggest next steps

Every output template file SHOULD:

- [ ] Be self-contained and understandable
- [ ] Provide placeholder examples
- [ ] Use consistent emoji markers
- [ ] Include inline comments for guidance
- [ ] Be domain-agnostic unless specified

---

## ğŸ¯ Domain-Specific Extensions

Toolkit developers can extend templates for specific domains:

### Example: MCP Domain

```jinja2
{# Extend base plan template #}
{% extends "workflows/plan-template.md.j2" %}

{% block additional_sections %}
## ğŸ”Œ MCP Protocol Compliance

### Server Configuration
```json
{
  "name": "{{ name }}",
  "version": "{{ version }}",
  "protocol": "mcp/1.0"
}
```

### Tools Definition
[Define MCP tools that will be exposed]

{% endblock %}
```

---

## ğŸ“ Example: Complete Template

See `templates/workflows/plan-template.md.j2` for a complete example.

---

## ğŸ”— How Commands and Templates Work Together

### Complete Workflow

```
1. User Action
   /toolkit:plan "Add user authentication"

2. AI reads Command (Layer 1)
   .cursor/commands/plan.md
   
   Content:
   - Context: Project info, entity model
   - Task: Generate implementation plan
   - Steps: How to analyze, structure, document
   - Template: Use templates/plan-template.md
   - Principles: Follow constitution

3. AI uses Template (Layer 2)
   templates/plan-template.md
   
   Structure:
   - Metadata section
   - Overview section
   - Requirements section
   - Technical design section
   - Implementation steps
   - References

4. AI generates Output
   specs/plan.md
   
   - Follows template structure
   - Fills with specific content
   - Uses entity model variables
   - Suggests next steps
```

### Key Points

1. **Command = Process** (How to think)
   - Provides context and guidance
   - Explains what to consider
   - References domain principles
   - Suggests approach

2. **Template = Structure** (What to produce)
   - Defines document layout
   - Specifies required sections
   - Sets formatting standards
   - Ensures consistency

3. **Independence**
   - Commands can exist without templates (e.g., `spec`, `constitution`)
   - Templates can be used by multiple commands
   - Both can be customized independently

### Creating Custom Command Systems

When creating domain-specific workflows:

**Step 1: Design the workflow**
```
What task needs AI assistance?
- Designing API endpoints?
- Generating test cases?
- Creating documentation?
```

**Step 2: Write command instructions**
```markdown
# commands/design-endpoint.md.j2

## Instructions
1. Analyze the API requirements
2. Consider REST best practices
3. Define request/response schemas
4. Use templates/endpoint-template.md
```

**Step 3: Create output template**
```markdown
# templates/endpoint-template.md.j2

# API Endpoint: [Name]

## Request
- Method: [GET/POST/PUT/DELETE]
- Path: [/api/endpoint]
...
```

**Step 4: Register in toolkit**
```yaml
slash_commands:
  - name: "design-endpoint"
    description: "Design API endpoint specification"
    template: "templates/endpoint-template.md.j2"
```

---

## ğŸ”„ Lifecycle

1. **Creation**: MetaSpec generates toolkit with templates
2. **Selection**: Toolkit developer chooses which templates to include
3. **Customization**: Toolkit developer extends templates if needed
4. **Usage**: AI agents use templates to generate specs
5. **Evolution**: Templates can be updated as toolkit matures

---

## ğŸš« Anti-Patterns

### âŒ Don't

- Generate code files from slash commands (use CLI commands instead)
- Create templates without clear structure
- Mix multiple concerns in one template
- Hardcode domain-specific logic in base templates
- Forget to link to related documents

### âœ… Do

- Generate specification documents (plans, tasks, checklists)
- Follow the standard structure
- Keep templates focused on one purpose
- Use template extension for domain-specific needs
- Always suggest next steps

---

## ğŸ“š References

- [Template Architecture](./TEMPLATE_ARCHITECTURE.md) - Three-layer template organization
- [MetaSpec AGENTS.md](../AGENTS.md) - Complete toolkit development guide
- [Spec-Kit Pattern](https://github.com/github/spec-kit) - Reference implementation
- [Template Examples](../src/metaspec/templates/) - library/ and meta/ examples

---

**Last Updated**: 2025-10-26

